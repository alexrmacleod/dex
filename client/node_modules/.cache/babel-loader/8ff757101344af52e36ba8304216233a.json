{"ast":null,"code":"import Web3 from 'web3';\nimport Dex from './contracts/Dex.json';\nimport ERC20Abi from './ERC20Abi.json';\n\nconst getWeb3 = () => {\n  return new Promise((resolve, reject) => {\n    // Wait for loading completion to avoid race conditions with web3 injection timing.\n    window.addEventListener(\"load\", async () => {\n      // Modern dapp browsers...\n      if (window.ethereum) {\n        const web3 = new Web3(window.ethereum);\n\n        try {\n          // Request account access if needed\n          await window.ethereum.enable(); // Acccounts now exposed\n\n          resolve(web3);\n        } catch (error) {\n          reject(error);\n        }\n      } // Legacy dapp browsers...\n      else if (window.web3) {\n          // Use Mist/MetaMask's provider.\n          const web3 = window.web3;\n          console.log(\"Injected web3 detected.\");\n          resolve(web3);\n        } // Fallback to localhost; use dev console port by default...\n        else {\n            const provider = new Web3.providers.HttpProvider(\"http://localhost:9545\");\n            const web3 = new Web3(provider);\n            console.log(\"No web3 instance injected, using Local web3.\");\n            resolve(web3);\n          }\n    });\n  });\n};\n\nconst getContracts = async web3 => {\n  const networkId = await web3.eth.net.getId();\n  const deployedNetwork = Dex.networks[networkId];\n  const dex = new web3.eth.Contract(Dex.abi, deployedNetwork && deployedNetwork.address);\n  const tokens = await dex.methods.getTokens().call();\n  const tokenContracts = tokens.reduce((acc, token) => ({ ...acc,\n    [web3.utils.hexToUtf8(token.ticker)]: new web3.eth.Contract(ERC20Abi, token.tokenAddress)\n  }), {});\n  return {\n    dex,\n    ...tokenContracts\n  };\n};\n\nexport { getWeb3, getContracts };","map":{"version":3,"sources":["/Users/alex/Documents/dex/client/src/utils.js"],"names":["Web3","Dex","ERC20Abi","getWeb3","Promise","resolve","reject","window","addEventListener","ethereum","web3","enable","error","console","log","provider","providers","HttpProvider","getContracts","networkId","eth","net","getId","deployedNetwork","networks","dex","Contract","abi","address","tokens","methods","getTokens","call","tokenContracts","reduce","acc","token","utils","hexToUtf8","ticker","tokenAddress"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;AACA,OAAOC,GAAP,MAAgB,sBAAhB;AACA,OAAOC,QAAP,MAAqB,iBAArB;;AAEA,MAAMC,OAAO,GAAG,MAAM;AACpB,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC;AACAC,IAAAA,MAAM,CAACC,gBAAP,CAAwB,MAAxB,EAAgC,YAAY;AAC1C;AACA,UAAID,MAAM,CAACE,QAAX,EAAqB;AACnB,cAAMC,IAAI,GAAG,IAAIV,IAAJ,CAASO,MAAM,CAACE,QAAhB,CAAb;;AACA,YAAI;AACF;AACA,gBAAMF,MAAM,CAACE,QAAP,CAAgBE,MAAhB,EAAN,CAFE,CAGF;;AACAN,UAAAA,OAAO,CAACK,IAAD,CAAP;AACD,SALD,CAKE,OAAOE,KAAP,EAAc;AACdN,UAAAA,MAAM,CAACM,KAAD,CAAN;AACD;AACF,OAVD,CAWA;AAXA,WAYK,IAAIL,MAAM,CAACG,IAAX,EAAiB;AACpB;AACA,gBAAMA,IAAI,GAAGH,MAAM,CAACG,IAApB;AACAG,UAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ;AACAT,UAAAA,OAAO,CAACK,IAAD,CAAP;AACD,SALI,CAML;AANK,aAOA;AACH,kBAAMK,QAAQ,GAAG,IAAIf,IAAI,CAACgB,SAAL,CAAeC,YAAnB,CACf,uBADe,CAAjB;AAGA,kBAAMP,IAAI,GAAG,IAAIV,IAAJ,CAASe,QAAT,CAAb;AACAF,YAAAA,OAAO,CAACC,GAAR,CAAY,8CAAZ;AACAT,YAAAA,OAAO,CAACK,IAAD,CAAP;AACD;AACF,KA7BD;AA8BD,GAhCM,CAAP;AAiCD,CAlCD;;AAoCA,MAAMQ,YAAY,GAAG,MAAMR,IAAN,IAAc;AACjC,QAAMS,SAAS,GAAG,MAAMT,IAAI,CAACU,GAAL,CAASC,GAAT,CAAaC,KAAb,EAAxB;AACA,QAAMC,eAAe,GAAGtB,GAAG,CAACuB,QAAJ,CAAaL,SAAb,CAAxB;AACA,QAAMM,GAAG,GAAG,IAAIf,IAAI,CAACU,GAAL,CAASM,QAAb,CACVzB,GAAG,CAAC0B,GADM,EAEVJ,eAAe,IAAIA,eAAe,CAACK,OAFzB,CAAZ;AAIA,QAAMC,MAAM,GAAG,MAAMJ,GAAG,CAACK,OAAJ,CAAYC,SAAZ,GAAwBC,IAAxB,EAArB;AACA,QAAMC,cAAc,GAAGJ,MAAM,CAACK,MAAP,CAAc,CAACC,GAAD,EAAMC,KAAN,MAAiB,EAClD,GAAGD,GAD+C;AAElD,KAACzB,IAAI,CAAC2B,KAAL,CAAWC,SAAX,CAAqBF,KAAK,CAACG,MAA3B,CAAD,GAAsC,IAAI7B,IAAI,CAACU,GAAL,CAASM,QAAb,CAClCxB,QADkC,EAElCkC,KAAK,CAACI,YAF4B;AAFY,GAAjB,CAAd,EAMnB,EANmB,CAAvB;AAOA,SAAO;AAAEf,IAAAA,GAAF;AAAO,OAAGQ;AAAV,GAAP;AACD,CAhBD;;AAkBA,SAAS9B,OAAT,EAAkBe,YAAlB","sourcesContent":["import Web3 from 'web3';\nimport Dex from './contracts/Dex.json';\nimport ERC20Abi from './ERC20Abi.json';\n\nconst getWeb3 = () => {\n  return new Promise((resolve, reject) => {\n    // Wait for loading completion to avoid race conditions with web3 injection timing.\n    window.addEventListener(\"load\", async () => {\n      // Modern dapp browsers...\n      if (window.ethereum) {\n        const web3 = new Web3(window.ethereum);\n        try {\n          // Request account access if needed\n          await window.ethereum.enable();\n          // Acccounts now exposed\n          resolve(web3);\n        } catch (error) {\n          reject(error);\n        }\n      }\n      // Legacy dapp browsers...\n      else if (window.web3) {\n        // Use Mist/MetaMask's provider.\n        const web3 = window.web3;\n        console.log(\"Injected web3 detected.\");\n        resolve(web3);\n      }\n      // Fallback to localhost; use dev console port by default...\n      else {\n        const provider = new Web3.providers.HttpProvider(\n          \"http://localhost:9545\"\n        );\n        const web3 = new Web3(provider);\n        console.log(\"No web3 instance injected, using Local web3.\");\n        resolve(web3);\n      }\n    });\n  });\n};\n\nconst getContracts = async web3 => {\n  const networkId = await web3.eth.net.getId();\n  const deployedNetwork = Dex.networks[networkId];\n  const dex = new web3.eth.Contract(\n    Dex.abi,\n    deployedNetwork && deployedNetwork.address,\n  );\n  const tokens = await dex.methods.getTokens().call();\n  const tokenContracts = tokens.reduce((acc, token) => ({\n      ...acc,\n      [web3.utils.hexToUtf8(token.ticker)]: new web3.eth.Contract(\n          ERC20Abi,\n          token.tokenAddress\n      )\n  }), {});\n  return { dex, ...tokenContracts }; \n}\n\nexport { getWeb3, getContracts };"]},"metadata":{},"sourceType":"module"}